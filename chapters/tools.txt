

linha do excel para unir texto =UNIRTEXTO(";";VERDADEIRO;(A2:A30))

##################################################################################################
############################################# PANDAS #############################################
##################################################################################################

# detectar todos valores nao nulos e tornar inteiros (trunca)
df.loc[df['x'].notnull(), 'x'].apply(int)

# ordena valores pela coluna col1 decrescente a começar pelos nulos
df.sort_values(by='col1', ascending=False, na_position='first')

# join de dataframe me left:
df_1 = pd.mergedf_1, df_2[['col1','col2']], how = 'left', left_on = 'nome_chave', right_on = 'nome_chave') 

# loc com duas condiçoes
df.loc[((df.col_num > 30) & (df.col_categ == 'cat')),'col_spec'] = 27.  

# substitui zero por nulo (NAN) em todo dataframe
df.replace(0, np.nan, inplace = True)
# para efetuar o inverso: 
df[col].fillna(0, inplace=True)



# mostrar nome de todas as linhas
pd.set_option('display.max_rows', None)

# renomear coluna
df.rename(columns = {'COL1':'col1', 'COL2':'col2'}, inplace = True)

# drop column
df.drop(columns=['col1', 'col2'], inplace=True)


# Identify what values are in TableB and not in TableA
key_diff = set(TableB.Key).difference(TableA.Key)
where_diff = TableB.Key.isin(key_diff)

# drop index sem deixar como coluna
df.reset_index(drop=True, inplace=True)

salvar dataframe sem index
pd.to_excel(r'file.xlsx', index = False)

# correr linhas de um data frame
for index, row in df.iterrows(): 
      lista = [row['colunaA'], row['colunaB'], row['colunaC']]
      maior = max(numero for numero in lista if numero != 0)  
      print(maior)

# sobre eixos 
# linhas  (axis=0)
# columns (axis=1)

# drop colunas nas quais todos os elementos sejam nulos (NAN):
df.dropna(axis=1, how='all') 

# drop linhas nas quais todos os elementos sejam nan:
df.dropna(axis=0, how='all')  

# converte varias colunas para inteiro (!!!!!! trunca):
df[['col1','col2']] = df[['col1','col2']].astype(int)


##################################################################################################
############################################# PACOTES ############################################ 
##################################################################################################

instala pacote forçadamente

pip install --trusted-host pypi.python.org --trusted-host pypi.org --trusted-host files.pythonhosted.org {package name}


##################################################################################################
############################################# LISTAS #############################################
##################################################################################################


# checar se algum item de uma lista contem 'pedaço' de palavra
lista_testa = ['aledj','abcd','defikhg']
[x for x in lista_testa if 'a' in x]

se começa com 'a':
[x for x in lista_testa if x.startswith('a')] 

##########
se string contem palavra

string = "This contains a word"
if "word" in string:
    print("Found")
else:
    print("Not Found")


##################################################################################################
############################################# PLOTLY #############################################
##################################################################################################

###################### plotly grafico de um conjunto de dados 

import plotly.express as px
import plotly.graph_objects as go
fig = px.scatter(  x=x_data,   y=sigmoid(x_data, *p0),   template='simple_white', width=700, height=500 )

fig.update_traces(marker=dict(size=10,
                              color='red',
                              line=dict(width=1,
                                        color='black')),
                  selector=dict(mode='markers'))
 
fig.add_trace(go.Scatter(  x = df_aval['avaliacao'], y= df_aval['real_renda'],  mode="markers", line_color="blue"))
 

fig.update_layout(
    title=" ",
    xaxis_title="avaliacao",
    yaxis_title="renda ",
    #legend_title="Legend Title",
    font=dict(
        family="Arial",
        size=20,
        color="black"
    )
)
fig.data = (fig.data[1],fig.data[0] )
fig.show() 



###################### plotly grafico de um conjunto de dados

import plotly.express as px
import plotly.graph_objects as go
fig = px.scatter(df_aval,  x=df_aval["avaliacao"],   y=df_aval["real_soluto"], color=df_aval["uf"], color_discrete_sequence=px.colors.qualitative.G10,  template='simple_white', width=700, height=500 )

fig.update_traces(marker=dict(size=10, 
                              line=dict(width=1,
                                        color='black')),
                  selector=dict(mode='markers'))
  
fig.update_layout(
    title=" ",
    xaxis_title="avaliacao",
    yaxis_title="soluto ",k
    #legend_title="Legend Title",
    font=dict(
        family="Arial",
        size=20,
        color="black"
    )
) 
fig.show() 

##### plotly cores

# dir(px.colors.sequential) # cores continuas disponiveis
# dir(px.colors.qualitative); # cores discretas disponiveis 


##### plotly TRENDLINE

trendline = "rolling", trendline_options=dict(function="median", window=30),  trendline_color_override="red"
trendline="ewm", trendline_options=dict(halflife=3)

trendline="rolling", trendline_options=dict(window=5, win_type="gaussian", function_args=dict(std=2))


show only trendlines
fig.data = [t for t in fig.data if t.mode == "lines"]

# plotly consultar cores continuas e discretas
# dir(px.colors.sequential) # cores continuas disponiveis
# dir(px.colors.qualitative); # cores discretas disponiveis 

 
